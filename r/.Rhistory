# XXXX complete the array (turn 't' into monte.carlo)
} else { # single threaded:
for (i in 1:N) { # (Could do this bit multi-process)
#resample (NOT SURE HOW THIS WORKS!!)
mc.samp <- trunc(runif(tot,min = 1,max = (tot + 1))) # Create a random number for each row
result[2,(1:tot)] <- result[1,mc.samp[1:tot]] # Store sampled data in result[2,] temporarily
for (j in 1:len) {
monte.carlo[i,j] <- sum(result[2,] == j) #compute reaggregate to areas
}
}
} # else
# Calculate the mean and confidence intervals for each area after the simulations
temp <- rep(0,N)
for (i in 1:len) {
monte.carlo[(N + 1),i] <- mean(monte.carlo[c(1:N),i])
temp[] <- sort(monte.carlo[c(1:N),i])
monte.carlo[(N + 2),i] <- temp[0.95 * N] #upper
monte.carlo[(N + 3),i] <- temp[0.05 * N] #lower
}
# Compute the S Index, in this case comparing the values from year to the next for each area
# Do this by adding up the number of times that the test data point is within the upper and lower bounds
# of the base data
S <-  sum(
(areas$test >= monte.carlo[(N + 3),]) & (areas$test <= monte.carlo[(N + 2),])
) / len
# Calculate excluding zero entries
# Same as above but also include the condition that there has to be a crime in the test data set
# as well as being within bounds.
S.nozero <- sum(
(areas$test >= monte.carlo[N + 3,]) & (areas$test <= monte.carlo[N + 2,]) & (areas$test > 0)
) / len
print(paste("S index: ",S, ". Excluding zeros: ",S.nozero))
# Store results ready to be returned when this is implemented as a function
areas@data$S = S # The s index, will be the same for each area (it is global)
areas@data$S.nozero = S.nozero
areas@data$mean <- monte.carlo[(N+1),1:len]       # Mean points in each area after resampling
areas@data$conf.upper <- monte.carlo[(N+2),1:len] # Lower confidence interval
areas@data$conf.lower <- monte.carlo[(N+3),1:len] # Upper confidence interval
t <- foreach(sim=1:N, crimes=rep(areas$base,N), .combine='c') %dopar% {
runSim(sim, crimes)
} # foreach
1:N
rep(areas$base,N)
areas$base
rep(5,areas$base)
list(areas$base)
rep(list(areas$base,N))
rep(list(areas$base),N)
t <- foreach(sim=1:N, crimes=rep(list(areas$base),N), .combine='c') %dopar% {
runSim(sim, crimes)
} # foreach
len <- length(areas) # The number of areas
tot <- sum(areas$base)    # The number of crimes
# An array to store the results of each monte carlo iteration temporarily.
# This is in long form (one row per crime). Dim 1=i, 2=sampled data (temp)
result <- array(0,c(2,tot))
# Generate the long form of the data for sampling - one row per crime
# (actually it's one crime per colum technically, but that doesn't really matter)
ct <- 0 # counter
for (i in 1:len) {
start <- ct + 1
end <- start + areas$base[i] - 1 # Number of crimes in area i
result[1,c(start:end)] <- i
ct <- end
}
# Now run the Monte-Carlo simulation
# Store the results of each iteration in the monte.carlo array.
# N columns are for the simulations for each run, remaining three columns are for the mean
# of all runs and the upper and lower confidence intervals.
monte.carlo <- array(0,c((N + 3),len))
# Do the simulations in single thread (normal) mode, or multi-process
if (multiprocess) {
# http://projects.revolutionanalytics.com/documents/parallelr/parallerrpkgs/
# http://stackoverflow.com/questions/1395309/how-to-make-r-use-all-processors
# Also see 'Using The foreach Package - CRAN'
library("foreach")
library("doMC") # Register a parallel backend (for mac)
runSim <- function(iteration, crimes) { # Run one simulation
# i is the simulation iteration number (not really used
# crimes is a list of number of crimes in each area
len <- length(crimes)      # The number of areas
tot <- sum(crimes)    # The number of crimes
res <- array(0,c(2,tot))  # Make a results array
ct <- 0 # counter
for (i in 1:len) {
start <- ct + 1
end <- start + crimes[i] - 1 # Number of crimes in area i
res[1,c(start:end)] <- i
ct <- end
}
mc.samp <- trunc(runif(tot, min = 1,max = (tot + 1))) # Create a random number for each row
res[2,(1:tot)] <- res[1,mc.samp[1:tot]] # Store sampled data in result[2,] temporarily
mc <- array(0,c(1,len)) # Store the re-aggregated results
for (j in 1:len) {
mc[1,j] <- sum(mc.samp[2,] == j) #compute reaggregate to areas
}
mc # Return this
} # myFunc
# XXXX CAN'T GET THIS WORKING!!
#t <- foreach(sim=1:N, .combine='c') %dopar% { trunc(sim) } # foreach
# XXXX COULD TRY PASSING AREAS DATA HERE AS WELL
t <- foreach(sim=1:N, crimes=rep(list(areas$base),N), .combine='c') %dopar% {
runSim(sim, crimes)
} # foreach
# XXXX complete the array (turn 't' into monte.carlo)
} else { # single threaded:
for (i in 1:N) { # (Could do this bit multi-process)
#resample (NOT SURE HOW THIS WORKS!!)
mc.samp <- trunc(runif(tot,min = 1,max = (tot + 1))) # Create a random number for each row
result[2,(1:tot)] <- result[1,mc.samp[1:tot]] # Store sampled data in result[2,] temporarily
for (j in 1:len) {
monte.carlo[i,j] <- sum(result[2,] == j) #compute reaggregate to areas
}
}
} # else
# Calculate the mean and confidence intervals for each area after the simulations
temp <- rep(0,N)
for (i in 1:len) {
monte.carlo[(N + 1),i] <- mean(monte.carlo[c(1:N),i])
temp[] <- sort(monte.carlo[c(1:N),i])
monte.carlo[(N + 2),i] <- temp[0.95 * N] #upper
monte.carlo[(N + 3),i] <- temp[0.05 * N] #lower
}
# Compute the S Index, in this case comparing the values from year to the next for each area
# Do this by adding up the number of times that the test data point is within the upper and lower bounds
# of the base data
S <-  sum(
(areas$test >= monte.carlo[(N + 3),]) & (areas$test <= monte.carlo[(N + 2),])
) / len
# Calculate excluding zero entries
# Same as above but also include the condition that there has to be a crime in the test data set
# as well as being within bounds.
S.nozero <- sum(
(areas$test >= monte.carlo[N + 3,]) & (areas$test <= monte.carlo[N + 2,]) & (areas$test > 0)
) / len
print(paste("S index: ",S, ". Excluding zeros: ",S.nozero))
# Store results ready to be returned when this is implemented as a function
areas@data$S = S # The s index, will be the same for each area (it is global)
areas@data$S.nozero = S.nozero
areas@data$mean <- monte.carlo[(N+1),1:len]       # Mean points in each area after resampling
areas@data$conf.upper <- monte.carlo[(N+2),1:len] # Lower confidence interval
areas@data$conf.lower <- monte.carlo[(N+3),1:len] # Upper confidence interval
c(4, list(areas$base))
rbind(4, list(areas$base))
len <- length(areas) # The number of areas
tot <- sum(areas$base)    # The number of crimes
# An array to store the results of each monte carlo iteration temporarily.
# This is in long form (one row per crime). Dim 1=i, 2=sampled data (temp)
result <- array(0,c(2,tot))
# Generate the long form of the data for sampling - one row per crime
# (actually it's one crime per colum technically, but that doesn't really matter)
ct <- 0 # counter
for (i in 1:len) {
start <- ct + 1
end <- start + areas$base[i] - 1 # Number of crimes in area i
result[1,c(start:end)] <- i
ct <- end
}
# Now run the Monte-Carlo simulation
# Store the results of each iteration in the monte.carlo array.
# N columns are for the simulations for each run, remaining three columns are for the mean
# of all runs and the upper and lower confidence intervals.
monte.carlo <- array(0,c((N + 3),len))
# Do the simulations in single thread (normal) mode, or multi-process
if (multiprocess) {
# http://projects.revolutionanalytics.com/documents/parallelr/parallerrpkgs/
# http://stackoverflow.com/questions/1395309/how-to-make-r-use-all-processors
# Also see 'Using The foreach Package - CRAN'
library("foreach")
library("doMC") # Register a parallel backend (for mac)
runSim <- function(iteration, crimes) { # Run one simulation
# i is the simulation iteration number (not really used
# crimes is a list of number of crimes in each area
len <- length(crimes)      # The number of areas
tot <- sum(crimes)    # The number of crimes
res <- array(0,c(2,tot))  # Make a results array
ct <- 0 # counter
for (i in 1:len) {
start <- ct + 1
end <- start + crimes[i] - 1 # Number of crimes in area i
res[1,c(start:end)] <- i
ct <- end
}
mc.samp <- trunc(runif(tot, min = 1,max = (tot + 1))) # Create a random number for each row
res[2,(1:tot)] <- res[1,mc.samp[1:tot]] # Store sampled data in result[2,] temporarily
mc <- array(0,c(1,len)) # Store the re-aggregated results
for (j in 1:len) {
mc[1,j] <- sum(mc.samp[2,] == j) #compute reaggregate to areas
}
mc # Return this
5
} # myFunc
# XXXX CAN'T GET THIS WORKING!!
#t <- foreach(sim=1:N, .combine='c') %dopar% { trunc(sim) } # foreach
# XXXX COULD TRY PASSING AREAS DATA HERE AS WELL
t <- foreach(sim=1:N, crimes=rep(list(areas$base),N), .combine='c') %dopar% {
runSim(sim, crimes)
} # foreach
# XXXX complete the array (turn 't' into monte.carlo)
} else { # single threaded:
for (i in 1:N) { # (Could do this bit multi-process)
#resample (NOT SURE HOW THIS WORKS!!)
mc.samp <- trunc(runif(tot,min = 1,max = (tot + 1))) # Create a random number for each row
result[2,(1:tot)] <- result[1,mc.samp[1:tot]] # Store sampled data in result[2,] temporarily
for (j in 1:len) {
monte.carlo[i,j] <- sum(result[2,] == j) #compute reaggregate to areas
}
}
} # else
# Calculate the mean and confidence intervals for each area after the simulations
temp <- rep(0,N)
for (i in 1:len) {
monte.carlo[(N + 1),i] <- mean(monte.carlo[c(1:N),i])
temp[] <- sort(monte.carlo[c(1:N),i])
monte.carlo[(N + 2),i] <- temp[0.95 * N] #upper
monte.carlo[(N + 3),i] <- temp[0.05 * N] #lower
}
# Compute the S Index, in this case comparing the values from year to the next for each area
# Do this by adding up the number of times that the test data point is within the upper and lower bounds
# of the base data
S <-  sum(
(areas$test >= monte.carlo[(N + 3),]) & (areas$test <= monte.carlo[(N + 2),])
) / len
# Calculate excluding zero entries
# Same as above but also include the condition that there has to be a crime in the test data set
# as well as being within bounds.
S.nozero <- sum(
(areas$test >= monte.carlo[N + 3,]) & (areas$test <= monte.carlo[N + 2,]) & (areas$test > 0)
) / len
print(paste("S index: ",S, ". Excluding zeros: ",S.nozero))
# Store results ready to be returned when this is implemented as a function
areas@data$S = S # The s index, will be the same for each area (it is global)
areas@data$S.nozero = S.nozero
areas@data$mean <- monte.carlo[(N+1),1:len]       # Mean points in each area after resampling
areas@data$conf.upper <- monte.carlo[(N+2),1:len] # Lower confidence interval
areas@data$conf.lower <- monte.carlo[(N+3),1:len] # Upper confidence interval
len <- length(areas) # The number of areas
tot <- sum(areas$base)    # The number of crimes
# An array to store the results of each monte carlo iteration temporarily.
# This is in long form (one row per crime). Dim 1=i, 2=sampled data (temp)
result <- array(0,c(2,tot))
# Generate the long form of the data for sampling - one row per crime
# (actually it's one crime per colum technically, but that doesn't really matter)
ct <- 0 # counter
for (i in 1:len) {
start <- ct + 1
end <- start + areas$base[i] - 1 # Number of crimes in area i
result[1,c(start:end)] <- i
ct <- end
}
# Now run the Monte-Carlo simulation
# Store the results of each iteration in the monte.carlo array.
# N columns are for the simulations for each run, remaining three columns are for the mean
# of all runs and the upper and lower confidence intervals.
monte.carlo <- array(0,c((N + 3),len))
# Do the simulations in single thread (normal) mode, or multi-process
if (multiprocess) {
# http://projects.revolutionanalytics.com/documents/parallelr/parallerrpkgs/
# http://stackoverflow.com/questions/1395309/how-to-make-r-use-all-processors
# Also see 'Using The foreach Package - CRAN'
library("foreach")
library("doMC") # Register a parallel backend (for mac)
runSim <- function(iteration, crimes) { # Run one simulation
# i is the simulation iteration number (not really used
# crimes is a list of number of crimes in each area
len <- length(crimes)      # The number of areas
tot <- sum(crimes)    # The number of crimes
res <- array(0,c(2,tot))  # Make a results array
ct <- 0 # counter
for (i in 1:len) {
start <- ct + 1
end <- start + crimes[i] - 1 # Number of crimes in area i
res[1,c(start:end)] <- i
ct <- end
}
mc.samp <- trunc(runif(tot, min = 1,max = (tot + 1))) # Create a random number for each row
res[2,(1:tot)] <- res[1,mc.samp[1:tot]] # Store sampled data in result[2,] temporarily
mc <- array(0,c(1,len)) # Store the re-aggregated results
for (j in 1:len) {
mc[1,j] <- sum(mc.samp[2,] == j) #compute reaggregate to areas
}
mc # Return this
5
} # myFunc
# XXXX CAN'T GET THIS WORKING!!
#t <- foreach(sim=1:N, .combine='c') %dopar% { trunc(sim) } # foreach
# XXXX COULD TRY PASSING AREAS DATA HERE AS WELL
t <- foreach(sim=1:N, crimes=rep(list(areas$base),N), .combine='c') %do% {
runSim(sim, crimes)
} # foreach
# XXXX complete the array (turn 't' into monte.carlo)
} else { # single threaded:
for (i in 1:N) { # (Could do this bit multi-process)
#resample (NOT SURE HOW THIS WORKS!!)
mc.samp <- trunc(runif(tot,min = 1,max = (tot + 1))) # Create a random number for each row
result[2,(1:tot)] <- result[1,mc.samp[1:tot]] # Store sampled data in result[2,] temporarily
for (j in 1:len) {
monte.carlo[i,j] <- sum(result[2,] == j) #compute reaggregate to areas
}
}
} # else
# Calculate the mean and confidence intervals for each area after the simulations
temp <- rep(0,N)
for (i in 1:len) {
monte.carlo[(N + 1),i] <- mean(monte.carlo[c(1:N),i])
temp[] <- sort(monte.carlo[c(1:N),i])
monte.carlo[(N + 2),i] <- temp[0.95 * N] #upper
monte.carlo[(N + 3),i] <- temp[0.05 * N] #lower
}
# Compute the S Index, in this case comparing the values from year to the next for each area
# Do this by adding up the number of times that the test data point is within the upper and lower bounds
# of the base data
S <-  sum(
(areas$test >= monte.carlo[(N + 3),]) & (areas$test <= monte.carlo[(N + 2),])
) / len
# Calculate excluding zero entries
# Same as above but also include the condition that there has to be a crime in the test data set
# as well as being within bounds.
S.nozero <- sum(
(areas$test >= monte.carlo[N + 3,]) & (areas$test <= monte.carlo[N + 2,]) & (areas$test > 0)
) / len
print(paste("S index: ",S, ". Excluding zeros: ",S.nozero))
# Store results ready to be returned when this is implemented as a function
areas@data$S = S # The s index, will be the same for each area (it is global)
areas@data$S.nozero = S.nozero
areas@data$mean <- monte.carlo[(N+1),1:len]       # Mean points in each area after resampling
areas@data$conf.upper <- monte.carlo[(N+2),1:len] # Lower confidence interval
areas@data$conf.lower <- monte.carlo[(N+3),1:len] # Upper confidence interval
len <- length(areas) # The number of areas
tot <- sum(areas$base)    # The number of crimes
# An array to store the results of each monte carlo iteration temporarily.
# This is in long form (one row per crime). Dim 1=i, 2=sampled data (temp)
result <- array(0,c(2,tot))
# Generate the long form of the data for sampling - one row per crime
# (actually it's one crime per colum technically, but that doesn't really matter)
ct <- 0 # counter
for (i in 1:len) {
start <- ct + 1
end <- start + areas$base[i] - 1 # Number of crimes in area i
result[1,c(start:end)] <- i
ct <- end
}
# Now run the Monte-Carlo simulation
# Store the results of each iteration in the monte.carlo array.
# N columns are for the simulations for each run, remaining three columns are for the mean
# of all runs and the upper and lower confidence intervals.
monte.carlo <- array(0,c((N + 3),len))
# Do the simulations in single thread (normal) mode, or multi-process
if (multiprocess) {
# http://projects.revolutionanalytics.com/documents/parallelr/parallerrpkgs/
# http://stackoverflow.com/questions/1395309/how-to-make-r-use-all-processors
# Also see 'Using The foreach Package - CRAN'
library("foreach")
library("doMC") # Register a parallel backend (for mac)
runSim <- function(iteration, crimes) { # Run one simulation
# i is the simulation iteration number (not really used
# crimes is a list of number of crimes in each area
len <- length(crimes)      # The number of areas
tot <- sum(crimes)    # The number of crimes
res <- array(0,c(2,tot))  # Make a results array
ct <- 0 # counter
for (i in 1:len) {
start <- ct + 1
end <- start + crimes[i] - 1 # Number of crimes in area i
res[1,c(start:end)] <- i
ct <- end
}
mc.samp <- trunc(runif(tot, min = 1,max = (tot + 1))) # Create a random number for each row
res[2,(1:tot)] <- res[1,mc.samp[1:tot]] # Store sampled data in result[2,] temporarily
mc <- array(0,c(1,len)) # Store the re-aggregated results
for (j in 1:len) {
mc[1,j] <- sum(mc.samp[2,] == j) #compute reaggregate to areas
}
mc # Return this
5
} # myFunc
# XXXX CAN'T GET THIS WORKING!!
#t <- foreach(sim=1:N, .combine='c') %dopar% { trunc(sim) } # foreach
# XXXX COULD TRY PASSING AREAS DATA HERE AS WELL
t <- foreach(sim=1:N, crimes=rep(list(areas$base),N), .combine='c') %do% {
runSim(sim, crimes)
} # foreach
# XXXX complete the array (turn 't' into monte.carlo)
} else { # single threaded:
for (i in 1:N) { # (Could do this bit multi-process)
#resample (NOT SURE HOW THIS WORKS!!)
mc.samp <- trunc(runif(tot,min = 1,max = (tot + 1))) # Create a random number for each row
result[2,(1:tot)] <- result[1,mc.samp[1:tot]] # Store sampled data in result[2,] temporarily
for (j in 1:len) {
monte.carlo[i,j] <- sum(result[2,] == j) #compute reaggregate to areas
}
}
} # else
# Calculate the mean and confidence intervals for each area after the simulations
temp <- rep(0,N)
for (i in 1:len) {
monte.carlo[(N + 1),i] <- mean(monte.carlo[c(1:N),i])
temp[] <- sort(monte.carlo[c(1:N),i])
monte.carlo[(N + 2),i] <- temp[0.95 * N] #upper
monte.carlo[(N + 3),i] <- temp[0.05 * N] #lower
}
# Compute the S Index, in this case comparing the values from year to the next for each area
# Do this by adding up the number of times that the test data point is within the upper and lower bounds
# of the base data
S <-  sum(
(areas$test >= monte.carlo[(N + 3),]) & (areas$test <= monte.carlo[(N + 2),])
) / len
# Calculate excluding zero entries
# Same as above but also include the condition that there has to be a crime in the test data set
# as well as being within bounds.
S.nozero <- sum(
(areas$test >= monte.carlo[N + 3,]) & (areas$test <= monte.carlo[N + 2,]) & (areas$test > 0)
) / len
print(paste("S index: ",S, ". Excluding zeros: ",S.nozero))
# Store results ready to be returned when this is implemented as a function
areas@data$S = S # The s index, will be the same for each area (it is global)
areas@data$S.nozero = S.nozero
areas@data$mean <- monte.carlo[(N+1),1:len]       # Mean points in each area after resampling
areas@data$conf.upper <- monte.carlo[(N+2),1:len] # Lower confidence interval
areas@data$conf.lower <- monte.carlo[(N+3),1:len] # Upper confidence interval
len <- length(areas) # The number of areas
tot <- sum(areas$base)    # The number of crimes
# An array to store the results of each monte carlo iteration temporarily.
# This is in long form (one row per crime). Dim 1=i, 2=sampled data (temp)
result <- array(0,c(2,tot))
# Generate the long form of the data for sampling - one row per crime
# (actually it's one crime per colum technically, but that doesn't really matter)
ct <- 0 # counter
for (i in 1:len) {
start <- ct + 1
end <- start + areas$base[i] - 1 # Number of crimes in area i
result[1,c(start:end)] <- i
ct <- end
}
# Now run the Monte-Carlo simulation
# Store the results of each iteration in the monte.carlo array.
# N columns are for the simulations for each run, remaining three columns are for the mean
# of all runs and the upper and lower confidence intervals.
monte.carlo <- array(0,c((N + 3),len))
# Do the simulations in single thread (normal) mode, or multi-process
if (multiprocess) {
# http://projects.revolutionanalytics.com/documents/parallelr/parallerrpkgs/
# http://stackoverflow.com/questions/1395309/how-to-make-r-use-all-processors
# Also see 'Using The foreach Package - CRAN'
library("foreach")
library("doMC") # Register a parallel backend (for mac)
runSim <- function(iteration, crimes) { # Run one simulation
# i is the simulation iteration number (not really used
# crimes is a list of number of crimes in each area
len <- length(crimes)      # The number of areas
tot <- sum(crimes)    # The number of crimes
res <- array(0,c(2,tot))  # Make a results array
ct <- 0 # counter
for (i in 1:len) {
start <- ct + 1
end <- start + crimes[i] - 1 # Number of crimes in area i
res[1,c(start:end)] <- i
ct <- end
}
mc.samp <- trunc(runif(tot, min = 1,max = (tot + 1))) # Create a random number for each row
res[2,(1:tot)] <- res[1,mc.samp[1:tot]] # Store sampled data in result[2,] temporarily
mc <- array(0,c(1,len)) # Store the re-aggregated results
for (j in 1:len) {
mc[1,j] <- sum(mc.samp[2,] == j) #compute reaggregate to areas
}
mc # Return this
5
} # myFunc
# XXXX CAN'T GET THIS WORKING!!
#t <- foreach(sim=1:N, .combine='c') %dopar% { trunc(sim) } # foreach
# XXXX COULD TRY PASSING AREAS DATA HERE AS WELL
t <- foreach(sim=1:N, crimes=rep(list(areas$base),N), .combine='c') %do% {
runSim(sim, crimes)
} # foreach
# XXXX complete the array (turn 't' into monte.carlo)
} else { # single threaded:
for (i in 1:N) { # (Could do this bit multi-process)
#resample (NOT SURE HOW THIS WORKS!!)
mc.samp <- trunc(runif(tot,min = 1,max = (tot + 1))) # Create a random number for each row
result[2,(1:tot)] <- result[1,mc.samp[1:tot]] # Store sampled data in result[2,] temporarily
for (j in 1:len) {
monte.carlo[i,j] <- sum(result[2,] == j) #compute reaggregate to areas
}
}
} # else
# Calculate the mean and confidence intervals for each area after the simulations
temp <- rep(0,N)
for (i in 1:len) {
monte.carlo[(N + 1),i] <- mean(monte.carlo[c(1:N),i])
temp[] <- sort(monte.carlo[c(1:N),i])
monte.carlo[(N + 2),i] <- temp[0.95 * N] #upper
monte.carlo[(N + 3),i] <- temp[0.05 * N] #lower
}
# Compute the S Index, in this case comparing the values from year to the next for each area
# Do this by adding up the number of times that the test data point is within the upper and lower bounds
# of the base data
S <-  sum(
(areas$test >= monte.carlo[(N + 3),]) & (areas$test <= monte.carlo[(N + 2),])
) / len
# Calculate excluding zero entries
# Same as above but also include the condition that there has to be a crime in the test data set
# as well as being within bounds.
S.nozero <- sum(
(areas$test >= monte.carlo[N + 3,]) & (areas$test <= monte.carlo[N + 2,]) & (areas$test > 0)
) / len
print(paste("S index: ",S, ". Excluding zeros: ",S.nozero))
# Store results ready to be returned when this is implemented as a function
areas@data$S = S # The s index, will be the same for each area (it is global)
areas@data$S.nozero = S.nozero
areas@data$mean <- monte.carlo[(N+1),1:len]       # Mean points in each area after resampling
areas@data$conf.upper <- monte.carlo[(N+2),1:len] # Lower confidence interval
areas@data$conf.lower <- monte.carlo[(N+3),1:len] # Upper confidence interval
